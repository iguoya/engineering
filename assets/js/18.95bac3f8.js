(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{373:function(t,s,a){"use strict";a.r(s);var r=a(25),v=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"模板方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板方法"}},[t._v("#")]),t._v(" 模板方法")]),t._v(" "),a("h2",{attrs:{id:"组件协作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件协作"}},[t._v("#")]),t._v(" 组件协作")]),t._v(" "),a("p",[t._v("框架和应用程序的划分")]),t._v(" "),a("p",[t._v("通过晚期绑定,来实现框架/应用程序之间的松耦合")]),t._v(" "),a("h2",{attrs:{id:"典型模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#典型模式"}},[t._v("#")]),t._v(" 典型模式")]),t._v(" "),a("p",[t._v("Template Method")]),t._v(" "),a("p",[t._v("Strategy")]),t._v(" "),a("p",[t._v("Observer / Event")]),t._v(" "),a("h2",{attrs:{id:"动机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动机"}},[t._v("#")]),t._v(" 动机")]),t._v(" "),a("p",[t._v("对于某一项结构,常常有稳定的"),a("strong",[t._v("整体操作结构")]),t._v(",但各个"),a("strong",[t._v("子步骤却有很多改变的需求")])]),t._v(" "),a("h2",{attrs:{id:"要点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#要点"}},[t._v("#")]),t._v(" 要点")]),t._v(" "),a("p",[a("strong",[t._v("不要调用我，让我来调用你")])]),t._v(" "),a("h2",{attrs:{id:"遇到的问题引出模板方法模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#遇到的问题引出模板方法模式"}},[t._v("#")]),t._v(" 遇到的问题引出模板方法模式")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("在面向对象系统的分析与设计过程中经常会遇到这样一种情况：对于某一个业务逻辑（算法实现）在不同的对象中有不同的细节实现，但是逻辑（算法）的框架（或通用的应用算法）是相同的。模板方法提供了这种情况的一个实现框架。")]),t._v(" "),a("p",[t._v("模板方法模式是采用继承的方式实现这一点：将逻辑（算法）框架放在抽象基类中，并定义好细节的接口，子类中实现细节。【注释 1】")])]),t._v(" "),a("p",[t._v("【注释 1】：Strategy 模式解决的是和模板方法模式类似的问题，但是 Strategy 模式是将逻辑（算法）封装到一个类中，并采取组合（委托）的方式解决这个问题。")]),t._v(" "),a("h2",{attrs:{id:"实现方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现方式"}},[t._v("#")]),t._v(" 实现方式")]),t._v(" "),a("p",[t._v("模板方法模式实际上就是利用面向对象中多态的概念实现算法实现细节和高层接口的松耦合。可以看到模板方法模式采取的是继承方式实现这一点的，由于继承是一种强约束性的条件，因此也给模板方法模式带来一些许多不方便的地方（有关这一点将在讨论中展开）。")]),t._v(" "),a("h2",{attrs:{id:"讨论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#讨论"}},[t._v("#")]),t._v(" 讨论")]),t._v(" "),a("p",[t._v("模板方法模式是很简单模式，但是也应用很广的模式。如上面的分析和实现中阐明的模板方法是采用继承的方式实现算法的异构，其关键点就是将通用算法封装在抽象基类中，并将不同的算法细节放到子类中实现。")]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),a("p",[t._v("模板方法模式获得一种反向控制结构效果，这也是面向对象系统的分析和设计中一个原则 DIP（依赖倒置：Dependency Inversion Principles）。其含义就是父类调用子类的操作（高层模块调用低层模块的操作），低层模块实现高层模块声明的接口。这样控制权在父类（高层模块），低层模块反而要依赖高层模块。")])]),t._v(" "),a("p",[t._v("继 承 的 强 制 性 约 束 关 系 也 让模板方法模 式 有 不 足 的 地 方 ， 我 们 可 以 看 到 对 于ConcreteClass 类中的实现的原语方法 Primitive1()，是不能被别的类复用。假设我们要创建一个 AbstractClass 的变体 AnotherAbstractClass，并且两者只是通用算法不一样，其原语操作想复用 AbstractClass 的子类的实现。但是这是不可能实现的，因为 ConcreteClass 继承自AbstractClass，也就继承了 AbstractClass 的通用算法，AnotherAbstractClass 是复用不了ConcreteClass 的实现，因为后者不是继承自前者。")]),t._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),a("p",[t._v("模板方法模式暴露的问题也正是继承所固有的问题，策略模式则通过组合（委托）来达到和模板方法模式类似的效果，其代价就是空间和时间上的代价，关于策略模式的详细讨论请参考 Strategy 模式解析。")])])])}),[],!1,null,null,null);s.default=v.exports}}]);