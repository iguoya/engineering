(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{364:function(t,a,s){"use strict";s.r(a);var r=s(25),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"面向对象设计原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面向对象设计原则"}},[t._v("#")]),t._v(" 面向对象设计原则")]),t._v(" "),s("h2",{attrs:{id:"设计原则比设计原则更重要"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计原则比设计原则更重要"}},[t._v("#")]),t._v(" 设计原则比设计原则更重要")]),t._v(" "),s("h2",{attrs:{id:"依赖倒置原则-dip"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置原则-dip"}},[t._v("#")]),t._v(" 依赖倒置原则(DIP)")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("高层模块(稳定)不应该依赖于底层模块(变化),应该依赖于稳定的模块(中间抽象模块)")])]),t._v(" "),s("li",[t._v("==抽象(稳定)模块不应该依赖实现细节,实现细节应该依赖于抽象模块==")])]),t._v(" "),s("h2",{attrs:{id:"开放封闭原则-ocp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开放封闭原则-ocp"}},[t._v("#")]),t._v(" 开放封闭原则 (OCP)")]),t._v(" "),s("ol",[s("li",[s("p",[s("strong",[t._v("对扩展开放,对更改封闭")])])]),t._v(" "),s("li",[s("p",[t._v("类模块应该是可扩展的,但是不可修改")])])]),t._v(" "),s("h2",{attrs:{id:"单一职责原则-srp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则-srp"}},[t._v("#")]),t._v(" 单一职责原则(SRP)")]),t._v(" "),s("ol",[s("li",[t._v("一个类应该仅有一个引起它变化的原因")]),t._v(" "),s("li",[t._v("类的变化的方向隐含着类的责任")])]),t._v(" "),s("h2",{attrs:{id:"liskov-替换原则-lsp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#liskov-替换原则-lsp"}},[t._v("#")]),t._v(" Liskov 替换原则 (LSP)")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("子类必须能够替代他们的基类(is - a)")])]),t._v(" "),s("li",[t._v("继承表达类型抽象")])]),t._v(" "),s("h2",{attrs:{id:"接口隔离原则-isp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则-isp"}},[t._v("#")]),t._v(" 接口隔离原则(ISP)")]),t._v(" "),s("ol",[s("li",[t._v("不应该强迫客户依赖他们不应该用的方法")]),t._v(" "),s("li",[s("strong",[t._v("接口保持小而稳定")])])]),t._v(" "),s("h2",{attrs:{id:"优先使用对象组合-而不是类继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优先使用对象组合-而不是类继承"}},[t._v("#")]),t._v(" 优先使用对象组合,而不是类继承")]),t._v(" "),s("ol",[s("li",[t._v("类继承为白箱复用,对象组合为黑箱复用")]),t._v(" "),s("li",[t._v("继承某种程度破坏了封装性,子类父类耦合度高")]),t._v(" "),s("li",[s("strong",[t._v("对象组合只要求被组合的对象具有良好定义的接口,耦合度低")])])]),t._v(" "),s("h2",{attrs:{id:"封装变化点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#封装变化点"}},[t._v("#")]),t._v(" 封装变化点")]),t._v(" "),s("p",[s("strong",[t._v("使用封装创建对象之间的分界层")]),t._v(",设计者对一侧修改,而不会对另一侧产生不良影响,实现对象间层次的松耦合")]),t._v(" "),s("h2",{attrs:{id:"针对接口编程-而不是针对实现编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#针对接口编程-而不是针对实现编程"}},[t._v("#")]),t._v(" 针对接口编程,而不是针对实现编程")]),t._v(" "),s("ol",[s("li",[t._v("不将变量类型声明为某个特定的具体类,而是声明为某个接口")]),t._v(" "),s("li",[s("strong",[t._v("客户无需知道对象的具体类型,只需要知道对象所具有的接口")])]),t._v(" "),s("li",[t._v("减少系统各部分的依赖关系,实现高内聚,松耦合")])]),t._v(" "),s("h1",{attrs:{id:"产业强盛的标志-接口标准化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#产业强盛的标志-接口标准化"}},[t._v("#")]),t._v(" 产业强盛的标志---接口标准化")])])}),[],!1,null,null,null);a.default=v.exports}}]);