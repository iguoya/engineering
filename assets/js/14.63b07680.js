(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{369:function(t,v,_){"use strict";_.r(v);var a=_(25),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"桥接模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#桥接模式"}},[t._v("#")]),t._v(" 桥接模式")]),t._v(" "),_("h2",{attrs:{id:"动机"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#动机"}},[t._v("#")]),t._v(" 动机")]),t._v(" "),_("blockquote",[_("p",[t._v("设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：")]),t._v(" "),_("ul",[_("li",[t._v("第一种设计方案是为每一种形状都提供一套各种颜色的版本。")]),t._v(" "),_("li",[t._v("第二种设计方案是根据实际需要对形状和颜色进行组合")])]),t._v(" "),_("p",[t._v("对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。"),_("strong",[t._v("桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。")])])]),t._v(" "),_("blockquote",[_("p",[t._v("总结面向对象实际上就两句话：一是松耦合（Coupling），二是高内聚（Cohesion）。"),_("strong",[t._v("面向对象系统追求的目标就是尽可能地提高系统模块内部的内聚（Cohesion）、尽可能降低模块间的耦合（Coupling）")]),t._v("。然而这也是面向对象设计过程中最为难把握的部分，大家肯定在OO 系统的开发过程中遇到这样的问题：")]),t._v(" "),_("ol",[_("li",[t._v("客户给了你一个需求，于是使用一个类来实现（A）；")]),t._v(" "),_("li",[t._v("客户需求变化，有两个算法实现功能，于是改变设计，我们通过一个抽象的基类，再定义两个具体类实现两个不同的算法（A1 和 A2）；")]),t._v(" "),_("li",[t._v("客户又告诉我们说对于不同的操作系统，于是再抽象一个层次，作为一个抽象基类A0，在分别为每个操作系统派生具体类（A00 和 A01，其中 A00 表示原来的类 A）实现不同操作系统上的客户需求，这样我们就有了一共 4 个类。")]),t._v(" "),_("li",[t._v("可能用户的需求又有变化，比如说又有了一种新的算法……..")]),t._v(" "),_("li",[t._v("我们陷入了一个需求变化的郁闷当中，也因此带来了类的迅速膨胀。")])])]),t._v(" "),_("h2",{attrs:{id:"定义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),_("p",[t._v("桥接模式(Bridge Pattern)：**将抽象部分与它的实现部分分离，使它们都可以独立地变化。**它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。")]),t._v(" "),_("h2",{attrs:{id:"结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#结构"}},[t._v("#")]),t._v(" 结构")]),t._v(" "),_("p",[t._v("Abstraction: 抽象类")]),t._v(" "),_("p",[t._v("RefinedAbstration: 扩充抽象类")]),t._v(" "),_("p",[t._v("Implementor: 实现类接口")]),t._v(" "),_("p",[t._v("ConcreteImplementor: 具体实现类")]),t._v(" "),_("h2",{attrs:{id:"分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分析"}},[t._v("#")]),t._v(" 分析")]),t._v(" "),_("p",[t._v("理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。")]),t._v(" "),_("ul",[_("li",[t._v("**抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。**在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。")]),t._v(" "),_("li",[t._v("实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。")]),t._v(" "),_("li",[t._v("脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。")]),t._v(" "),_("li",[_("strong",[t._v("桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意")]),t._v("。")])]),t._v(" "),_("h2",{attrs:{id:"应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[t._v("#")]),t._v(" 应用")]),t._v(" "),_("blockquote",[_("p",[t._v("在以下情况下可以使用桥接模式：")]),t._v(" "),_("ul",[_("li",[t._v("如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。")]),t._v(" "),_("li",[t._v("抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。")]),t._v(" "),_("li",[t._v("一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。")]),t._v(" "),_("li",[t._v("虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。")]),t._v(" "),_("li",[t._v("对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。")])])]),t._v(" "),_("blockquote",[_("p",[t._v("如果需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Linux、Unix等）上播放多种格式的视频文件，常见的视频格式包括MPEG、RMVB、AVI、WMV等。现使用桥接模式设计该播放器。")])])])}),[],!1,null,null,null);v.default=e.exports}}]);